/*
 * Copyright (c) 2016 ReportTable Alexander Seitz
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * 
 */
package analyse;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import utilities.OutputStrings;
import utilities.Pipelines;

/**
 * Class for the analsyis of the results generated by the
 * clip and merge step of the pipeline.
 * 
 * @author Alexander Seitz
 *
 */
public class AnalyzeClipAndMerge extends AbstractAnalyze {
	
	// member variables
	private String numberUsableReadsBeforeMerging = OutputStrings.notFound;
	private String numberMergedReads = OutputStrings.notFound;
	private String perCentMergedReads = OutputStrings.notFound;
	private String version = OutputStrings.notFound;
	private boolean mergedOnly = false;
	
	/**
	 * Constructor, the given Folder should point to the root directory of
	 * the sample, containing the folders generated by the pipeline.
	 * @param currentFolder	the root folder of the sample
	 */
	public AnalyzeClipAndMerge(File currentFolder){
		super(currentFolder);
		File dataDir = this.getCurrFolder(Pipelines.ClipAndMerge);
//		File dataDir = new File(this.sampleFolder + "/" + Pipelines.ClipAndMerge.toString());
		if(dataDir == null){
			return;
		}
		String[] names = dataDir.list();
		boolean found = false;
		int numfqFiles = 0;
		for(String name: names){
			if(name.endsWith(".fq.gz")){
				numfqFiles++;
			}
			File currFile = new File(dataDir+"/"+name);
			if(currFile.isFile() && currFile.getName().endsWith(".log")){
				found = true;
				parseFile(currFile);
			}
		}
		if(numfqFiles>1){
			this.mergedOnly = true;
		}
		if(!found){
		names = this.sampleFolder.list();
			for(String name: names){
				File currFile = new File(this.sampleFolder+"/"+name);
				if(currFile.isFile() && currFile.getName().equals("log.log")){
					parseFile(currFile);
				}
			}
		}
	}

	/**
	 * @return the mergedOnly
	 */
	public boolean isMergedOnly() {
		return mergedOnly;
	}

	// parse the given file for the needed information
	private void parseFile(File currFile) {
		try {
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(new FileReader(currFile));
			String currLine = "";
			boolean started = false;
			// the results are located after the file contains the Message "Finished merging!"
			while((currLine = br.readLine()) != null){
				if(!started && currLine.contains("ClipAndMerge")){
					String[] splittedLine = currLine.split(" ");
					this.version = splittedLine[splittedLine.length-1].trim();
					this.version = this.version.replace(")", "");
				}
				if(!started && currLine.contains("Finished merging!")
						|| currLine.contains("[Merging]")){
					started = true;
					continue;
				}
				if(!started){
					continue;
				}
				if(currLine.contains("Number of usable reads")
						|| currLine.contains("Number of usable reads in the output file(s)")){
					String[] splittedLine = currLine.split(" ");
					this.numberUsableReadsBeforeMerging = splittedLine[splittedLine.length-1].trim();
					continue;
				}
				if(currLine.contains("Number of merged reads")
						|| currLine.contains("Number of usable merged reads")){
					String[] splittedLine = currLine.split(" ");
					this.numberMergedReads = splittedLine[splittedLine.length-1].trim();
					continue;
				}
				if(currLine.contains("Percentage of merged reads")
						|| currLine.contains("Percentage of usable merged reads")){
					String[] splittedLine = currLine.split(" ");
					this.perCentMergedReads = splittedLine[splittedLine.length-2].trim();
					this.perCentMergedReads;
					break;
				}
			}
		} catch (IOException e) {
			
		}
		
	}

	/**
	 * @return the number of Usable Reads that were there Before the Merging step
	 */
	public String getNumberUsableReadsBeforeMerging() {
		return numberUsableReadsBeforeMerging;
	}

	/**
	 * @return the number of Merged Reads
	 */
	public String getNumberMergedReads() {
		return numberMergedReads;
	}

	/**
	 * @return the per Cent of Merged Reads
	 */
	public String getPerCentMergedReads() {
		return perCentMergedReads;
	}

	/**
	 * @return the version
	 */
	public String getVersion() {
		return version;
	}

}
