/*
 * Copyright (c) 2016 ReportTable Alexander Seitz
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * 
 */
package analyse;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Locale;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;

import utilities.OutputStrings;
import utilities.Pipelines;

/**
 * Class for the analsyis of the results generated by the
 * clip and merge step of the pipeline.
 * 
 * @author Alexander Seitz
 *
 */
public class AnalyzeClipAndMerge extends AbstractAnalyze {
	
	// member variables
	private String numberUsableReadsAfterMerging = OutputStrings.notFound;
	private String numberMergedReads = OutputStrings.notFound;
	private String perCentMergedReads = OutputStrings.notFound;
	private String unattemptedMappedReads = OutputStrings.notFound;
	private String version = OutputStrings.notFound;
	private boolean mergedOnly = false;
	
	/**
	 * Constructor, the given Folder should point to the root directory of
	 * the sample, containing the folders generated by the pipeline.
	 * @param currentFolder	the root folder of the sample
	 */
	public AnalyzeClipAndMerge(File currentFolder){
		super(currentFolder);
		File dataDir = this.getCurrFolder(Pipelines.ClipAndMerge);
//		File dataDir = new File(this.sampleFolder + "/" + Pipelines.ClipAndMerge.toString());
		if(dataDir == null){
			return;
		}
		String[] names = dataDir.list();
		boolean found = false;
		for(String name: names){
			File currFile = new File(dataDir+"/"+name);
			if(currFile.isFile() && currFile.getName().endsWith(".log")){
				found = true;
				parseFile(currFile);
			}
			if(currFile.isFile() && currFile.getName().endsWith(".settings")){
				found = true;
				parseARFile(currFile);
			}
		}
		try {
			String fastqTrack = new String(Files.readAllBytes(Paths.get(dataDir+System.getProperty("file.separator")+"track_fastq.log")), StandardCharsets.UTF_8).trim();
			if(fastqTrack.equals("only_merged")){
				this.mergedOnly = true;
			}
		} catch (IOException e) {
		}
		if(!found){
		names = this.sampleFolder.list();
			for(String name: names){
				File currFile = new File(this.sampleFolder+"/"+name);
				if(currFile.isFile() && currFile.getName().equals("log.log")){
					parseFile(currFile);
				}
			}
		}
	}

	/**
	 * @return the mergedOnly
	 */
	public boolean isMergedOnly() {
		return mergedOnly;
	}
	


	// parse the given file for the needed information (from Adapter Removal output)
	private void parseARFile(File currFile) {
		try {
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(new FileReader(currFile));
			String currLine = "";
			boolean started = false;
			Integer inputReads = 0;
			Integer singletonReads = 0;
			Integer mergedReads = 0;
			Integer theoreticalOutputReads = 0;
			// the results are located after the file contains the Message "Finished merging!"
			while((currLine = br.readLine()) != null){
//				if(!started && currLine.contains("ClipAndMerge")){
//					String[] splittedLine = currLine.split(" ");
//					this.version = splittedLine[splittedLine.length-1].trim();
//					this.version = this.version.replace(")", "");
//				}
				if(!started && currLine.contains("[Trimming statistics]")){
					started = true;
					continue;
				}
				if(!started){
					continue;
				}
				if(currLine.contains("Total number of read pairs")){
					String[] splittedLine = currLine.split(":");
					inputReads = Integer.parseInt(splittedLine[splittedLine.length-1].trim());
					continue;
				}
				if(currLine.contains("Number of singleton mate 1 reads")){
					String[] splittedLine = currLine.split(":");
					singletonReads += Integer.parseInt(splittedLine[splittedLine.length-1].trim());
					continue;
				}
				if(currLine.contains("Number of singleton mate 2 reads")){
					String[] splittedLine = currLine.split(":");
					singletonReads += Integer.parseInt(splittedLine[splittedLine.length-1].trim());
					continue;
				}
				if(currLine.contains("Number of full-length collapsed pairs")){
					String[] splittedLine = currLine.split(":");
					mergedReads += Integer.parseInt(splittedLine[splittedLine.length-1].trim());
					continue;
				}
				if(currLine.contains("Number of truncated collapsed pairs")){
					String[] splittedLine = currLine.split(":");
					mergedReads += Integer.parseInt(splittedLine[splittedLine.length-1].trim());
					continue;
				}
				if(currLine.contains("Number of retained reads")){
					String[] splittedLine = currLine.split(":");
					theoreticalOutputReads = Integer.parseInt(splittedLine[splittedLine.length-1].trim());
					continue;
				}
			}
			this.numberUsableReadsAfterMerging = ""+(singletonReads+mergedReads);
			this.numberMergedReads = ""+mergedReads;
			this.perCentMergedReads = String.format(Locale.ENGLISH, "%.3f", (100*(double)mergedReads)/((double)inputReads));
			this.unattemptedMappedReads = ""+(theoreticalOutputReads-singletonReads-mergedReads);
			
		} catch (IOException e) {
			
		}
		this.mergedOnly = false;
		
	}

	// parse the given file for the needed information
	private void parseFile(File currFile) {
		try {
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(new FileReader(currFile));
			String currLine = "";
			boolean started = false;
			// the results are located after the file contains the Message "Finished merging!"
			while((currLine = br.readLine()) != null){
				if(!started && currLine.contains("ClipAndMerge")){
					String[] splittedLine = currLine.split(" ");
					this.version = splittedLine[splittedLine.length-1].trim();
					this.version = this.version.replace(")", "");
				}
				if(!started && currLine.contains("Finished merging!")
						|| currLine.contains("[Merging]")){
					started = true;
					continue;
				}
				if(!started){
					continue;
				}
				if(currLine.contains("Number of usable reads")
						|| currLine.contains("Number of usable reads in the output file(s)")){
					String[] splittedLine = currLine.split(" ");
					this.numberUsableReadsAfterMerging = splittedLine[splittedLine.length-1].trim();
					continue;
				}
				if(currLine.contains("Number of merged reads")
						|| currLine.contains("Number of usable merged reads")){
					String[] splittedLine = currLine.split(" ");
					if(!"0".equals(splittedLine[splittedLine.length-1].trim())){
						this.numberMergedReads = splittedLine[splittedLine.length-1].trim();
					}
					continue;
				}
				if(currLine.contains("Percentage of merged reads")
						|| currLine.contains("Percentage of usable merged reads")){
					String[] splittedLine = currLine.split(" ");
					if(!"0.0".equals(splittedLine[splittedLine.length-2].trim())){
						this.perCentMergedReads = splittedLine[splittedLine.length-2].trim();
					}
					break;
				}
			}
		} catch (IOException e) {
			
		}
		
	}

	/**
	 * @return the number of Usable Reads that were there Before the Merging step
	 */
	public String getNumberUsableReadsAfterMerging() {
		return numberUsableReadsAfterMerging;
	}

	/**
	 * @return the number of Merged Reads
	 */
	public String getNumberMergedReads() {
		return numberMergedReads;
	}

	/**
	 * @return the per Cent of Merged Reads
	 */
	public String getPerCentMergedReads() {
		return perCentMergedReads;
	}

	/**
	 * @return the unattemptedMappedReads
	 */
	public String getUnattemptedMappedReads() {
		return unattemptedMappedReads;
	}

	/**
	 * @return the version
	 */
	public String getVersion() {
		return version;
	}

}
