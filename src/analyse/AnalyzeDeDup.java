/*
 * Copyright (c) 2016 ReportTable Alexander Seitz
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * 
 */
package analyse;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import utilities.OutputStrings;
import utilities.Pipelines;

/**
 * Class for the analsyis of the results generated by the
 * better remove duplicates step of the pipeline.
 * 
 * @author Alexander Seitz
 *
 */
public class AnalyzeDeDup extends AbstractAnalyze{
	
	// the number of duplicates that were removed by the program
	private String duplicatesRemoved = OutputStrings.notFound;
	private String mtnucratio = OutputStrings.notFound;
	private String numMitochondrealReads = OutputStrings.notFound;
	private String avgCoverageOnMt = OutputStrings.notFound;

	/**
	 * Constructor, the given Folder should point to the root directory of
	 * the sample, containing the folders generated by the pipeline.
	 * @param currentFolder	the root folder of the sample
	 */
	public AnalyzeDeDup(File currentFolder) {
		// init the variables
		super(currentFolder);
		// get the name of the Subdirectory containing the needed File
//		File dataDir = new File(this.sampleFolder.getAbsolutePath() + "/" + Pipelines.BetterRMDup.toString());
		File dataDir = this.getCurrFolder(Pipelines.DeDup);
		// only continue, if this directory exists
//		if(dataDir.exists()){
		if(dataDir != null){
			// iterate through all files in the folder, until the desired File is found
			// parse this file
			String[] names = dataDir.list();
			for(String name:names){
				File currFile = new File(dataDir+"/"+name);
				if(currFile.isFile()){
					if(currFile.getName().endsWith(".log")){
						parseFile(currFile);
					}else if(currFile.getName().endsWith(".mtnucratio")){
						AnalyzeMtNuc analyzeMtNuc = new AnalyzeMtNuc(currFile);
						this.mtnucratio = analyzeMtNuc.getMtnucratio();
						this.numMitochondrealReads = analyzeMtNuc.getNumMitochondrealReads();
						this.avgCoverageOnMt = analyzeMtNuc.getAvgCoverageOnMt();
					}
				}
			}
		}
	}

	// parse the given file for the needed information
	private void parseFile(File currFile) {
		try {
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(new FileReader(currFile));
			String currLine = "";
			while((currLine = br.readLine()) != null){
				if(currLine.contains("Total removed")){
					String[] lineSplitted = currLine.split(" ");
					this.duplicatesRemoved = lineSplitted[lineSplitted.length-1].trim();
					continue;
				}
			}
		} catch (IOException e) {
		}
	}

	/**
	 * Getter Method for the field duplicatesRemoved. This field contains the
	 * number of duplicates that were removed by the program
	 * 
	 * @return the number of duplicates removed by the program
	 */
	public String getDuplicatesRemoved() {
		return duplicatesRemoved;
	}

	/**
	 * Getter Method for the field mtnucratio. This fields contains the ratio between
	 * the mitochondrial to the nuclear DNA
	 * @return the ratio of the mitochondiral to the nuclear dna
	 */
	public String getMtnucratio() {
		return mtnucratio;
	}

	/**
	 * Getter method for the field containing the number fo mitochondreal reads
	 * @return the number of mitochondreal reads
	 */
	public String getNumMitochondrealReads() {
		return numMitochondrealReads;
	}

	/**
	 * Getter method for the field containing the average coverage of the
	 * mitochondreal DNA
	 * @return the the average coverage on the mitochondreal DNA
	 */
	public String getAvgCoverageOnMt() {
		return avgCoverageOnMt;
	}
}
