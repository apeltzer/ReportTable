/*
 * Copyright (c) 2016 ReportTable Alexander Seitz
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *
 */
package analyse;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;

import utilities.OutputStrings;
import utilities.Pipelines;

/**
 * Class for the analysis of the results generated by the
 * samtools step of the pipeline.
 *
 * @author Alexander Seitz
 *
 */
public class AnalyzeSamtools extends AbstractAnalyze {

	// member variables
	private String mapped = OutputStrings.notFound;
	private String endogenousDNA = OutputStrings.notFound;
	private String mtnucratio = OutputStrings.notFound;
	private String numMitochondrealReads = OutputStrings.notFound;
	private String avgCoverageOnMt = OutputStrings.notFound;
	private String numReads = OutputStrings.notFound;
	private String unmapped = OutputStrings.notFound;

	private String mappedQF = OutputStrings.notFound;
	private String endogenousDNAQF = OutputStrings.notFound;
	private String numReadsQF = OutputStrings.notFound;
	private String unmappedQF = OutputStrings.notFound;

	/**
	 * Constructor, the given Folder should point to the root directory of
	 * the sample, containing the folders generated by the pipeline.
	 * @param currentFolder	the root folder of the sample
	 */
	public AnalyzeSamtools(File currentFolder) {
		super(currentFolder);
		this.sampleFolder = currentFolder;
		File dataDir = this.getCurrFolder(Pipelines.Samtools);
		if(dataDir != null){
			String[] names = dataDir.list();
			List<File> statsFiles = new LinkedList<File>();
			for(String name:names){
				File currFile = new File(dataDir+"/"+name);
				if(currFile.isFile()){
					if(currFile.getName().endsWith(".stats")){
						statsFiles.add(currFile);
					}else if(currFile.getName().endsWith("mtnucratio")){
						AnalyzeMtNuc analyzeMtNuc = new AnalyzeMtNuc(currFile);
						this.mtnucratio = analyzeMtNuc.getMtnucratio();
						this.numMitochondrealReads = analyzeMtNuc.getNumMitochondrealReads();
						this.avgCoverageOnMt = analyzeMtNuc.getAvgCoverageOnMt();
					}
				}
			}
			if(statsFiles.size() == 1){
				parseFlagstatsFile(statsFiles.get(0));
				calculateNumReadsAndEndogenousDNA();
			}else if(statsFiles.size() == 2){
				File f1 = statsFiles.get(0);
				File f2 = statsFiles.get(1);
				// first file
				parseFlagstatsFile(f1);
				// save results from first file
				String tmpMapped = this.mapped;
				String tmpNumReads = this.numReads;
				String tmpEndogen = this.endogenousDNA;
				String tmpUnmapped = this.unmapped;
				// second file
				parseFlagstatsFile(f2);
				// combine the two results
				// if there is a difference between the two files
				if(!(tmpMapped.equals(this.mapped))){
					Integer mappedTmp = Integer.parseInt(tmpMapped);
					Integer currMapped = Integer.parseInt(this.mapped);
					if(currMapped > mappedTmp){
						this.mappedQF = tmpMapped;
						this.numReadsQF = tmpNumReads;
						this.endogenousDNAQF = tmpEndogen;
						this.unmappedQF = tmpUnmapped;
					}else{
						this.mappedQF = this.mapped;
						this.numReadsQF = this.numReads;
						this.endogenousDNAQF = this.endogenousDNA;
						this.unmappedQF = this.unmapped;

						this.mapped = tmpMapped;
						this.numReads = tmpNumReads;
						this.endogenousDNA = tmpEndogen;
						this.unmapped = tmpUnmapped;
					}
				}
				calculateNumReadsAndEndogenousDNA();
			}
		}
	}

	/**
	 *
	 */
	private void calculateNumReadsAndEndogenousDNA() {
		if(!OutputStrings.notFound.equals(this.mapped) && !OutputStrings.notFound.equals(this.unmapped)&& !OutputStrings.notFound.equals(this.mappedQF)){
			Double mappedReads = Double.parseDouble(this.mapped);
			Double unmappedReads = Double.parseDouble(this.unmapped);
			Double numberReads = mappedReads + unmappedReads;
			this.numReads = String.format("%.0f", numberReads);
			this.endogenousDNA = String.format("%.3f", (mappedReads / numberReads) * 100);
			if(this.mappedQF.length() > 0 && !this.mapped.equals(this.mappedQF)){
				Double mappedReadsQF = Double.parseDouble(this.mappedQF);
				Double unmappedReadsQF = Double.parseDouble(this.unmappedQF);
				Double numberReadsQF = mappedReadsQF + unmappedReadsQF;
				this.numReadsQF = String.format("%s", numberReadsQF);
				this.endogenousDNAQF = String.format("%.3f", (mappedReadsQF / numberReads) * 100);
				this.endogenousDNA = this.endogenousDNAQF;
				this.endogenousDNAQF = OutputStrings.notFound;
			}
		}
	}

	private void parseFlagstatsFile(File currFile) {
		Integer all = 0;
		Integer mappedR = 0;
		try {
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(new FileReader(currFile));
			String currLine = "";
			while((currLine = br.readLine()) != null){
				if(currLine.contains("in total")){
					String[] splitted = currLine.split(" ");
					this.numReads = splitted[0].trim();
					all = Integer.parseInt(this.numReads);
				}else if(currLine.contains("mapped (")){
					String[] splitted = currLine.split(" ");
					this.mapped = splitted[0].trim();
					mappedR = Integer.parseInt(this.mapped);
				}
			}
		} catch (IOException e) {
		}
		if((all != 0.0) && (mappedR != 0.0)){
			this.unmapped = ""+(all-mappedR);
		}
	}

	/**
	 * Getter method for the field containing the number of mapped reads before
	 * duplicate removal
	 * @return the number mapped reads before dupplicated removal
	 */
	public String getMapped() {
		return mapped;
	}

	/**
	 * Getter method for the field containing the percentage of endogenous DNA
	 * @return the percentage of endogenous DNA
	 */
	public String getEndogenousDNA() {
		return endogenousDNA;
	}

	/**
	 * Getter Method for the field mtnucratio. This fields contains the ratio between
	 * the mitochondrial to the nuclear DNA
	 * @return the ratio of the mitochondiral to the nuclear dna
	 */
	public String getMtnucratio() {
		return mtnucratio;
	}

	/**
	 * Getter method for the field containing the number fo mitochondreal reads
	 * @return the number of mitochondreal reads
	 */
	public String getNumMitochondrealReads() {
		return numMitochondrealReads;
	}

	/**
	 * Getter method for the field containing the average coverage of the
	 * mitochondreal DNA
	 * @return the the average coverage on the mitochondreal DNA
	 */
	public String getAvgCoverageOnMt() {
		return avgCoverageOnMt;
	}

	/**
	 * Getter for the total number of reads that were tried to map
	 * @return the total number of reads
	 */
	public String getNumReads() {
		return numReads;
	}

	/**
	 * @return the mappedQF
	 */
	public String getMappedQF() {
		return mappedQF;
	}

	/**
	 * @return the endogenousDNAQF
	 */
	public String getEndogenousDNAQF() {
		return endogenousDNAQF;
	}

	/**
	 * @return the numReadsQF
	 */
	public String getNumReadsQF() {
		return numReadsQF;
	}

	/**
	 * @return the unmappedQF
	 */
	public String getUnmappedQF() {
		return unmappedQF;
	}

}
