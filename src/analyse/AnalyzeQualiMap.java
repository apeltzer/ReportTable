/*
 * Copyright (c) 2016 ReportTable Alexander Seitz
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * 
 */
package analyse;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import main.Main;
import utilities.OutputStrings;
import utilities.Pipelines;

/**
 * Class for the analsyis of the results generated by the
 * Quali Map step of the pipeline.
 * 
 * @author Alexander Seitz
 *
 */
public class AnalyzeQualiMap extends AbstractAnalyze {

	// member variables
	private String mappedReads = OutputStrings.notFound;
	private String gc = OutputStrings.notFound;
	private String meanCoverage = OutputStrings.notFound;
	private String stdCoverage = OutputStrings.notFound;
	private String coverage1x = OutputStrings.notFound;
	private String coverage2x = OutputStrings.notFound;
	private String coverage3x = OutputStrings.notFound;
	private String coverage4x = OutputStrings.notFound;
	private String coverage5x = OutputStrings.notFound;

	/**
	 * @return the coverage2x
	 */
	public String getCoverage1x() {
		return coverage1x;
	}

	/**
	 * @return the coverage2x
	 */
	public String getCoverage2x() {
		return coverage2x;
	}

	/**
	 * @return the coverage3x
	 */
	public String getCoverage3x() {
		return coverage3x;
	}

	/**
	 * @return the coverage4x
	 */
	public String getCoverage4x() {
		return coverage4x;
	}

	/**
	 * @return the coverage5x
	 */
	public String getCoverage5x() {
		return coverage5x;
	}

	/**
	 * Constructor, the given Folder should point to the root directory of
	 * the sample, containing the folders generated by the pipeline.
	 * @param workingDirectory	the root folder of the sample
	 */
	public AnalyzeQualiMap(File workingDirectory) {
		super(workingDirectory);
		this.sampleFolder = workingDirectory;
//		File dataDir = new File(this.sampleFolder.getAbsolutePath() + "/" + Pipelines.QualiMap.toString());
		File dataDir = this.getCurrFolder(Pipelines.QualiMap);
//		if(dataDir.exists()){
		if(dataDir != null){
			String[] names = dataDir.list();
			for(String name:names){
				File currFile = new File(dataDir.getAbsolutePath() + "/" + name);
				if(currFile.isDirectory()){
					analyzeQualiMapResults(currFile);
					break;
				}
			}
		}
	}

	// find the correct file in the given folder
	private void analyzeQualiMapResults(File currFolder) {
		String[] names = currFolder.list();
		for(String name:names){
			File currFile = new File(currFolder.getAbsolutePath() + "/" + name);
			if(currFile.isFile() && currFile.getName().endsWith(".txt")){
				parseFile(currFile);
				break;
			}
		}
	}

	// parse the given file for the needed information 
	private void parseFile(File currFile) {
		try {
			@SuppressWarnings("resource")
			BufferedReader br = new BufferedReader(new FileReader(currFile));
			String currLine = "";
			while((currLine = br.readLine()) != null){
				if(currLine.contains("number of mapped reads")){
					String[] lineSplitted = currLine.split(" ");
					this.mappedReads = lineSplitted[lineSplitted.length-2].trim();
					this.mappedReads = this.mappedReads.replace(",", "");
					this.mappedReads = this.mappedReads.replace(".", "");
				}else if(currLine.contains("GC percentage")){
					String[] lineSplitted = currLine.split(" ");
					this.gc = lineSplitted[lineSplitted.length-1].trim();
					this.gc = this.gc.replace("%", "").replace(",", ".").trim();
					this.gc += OutputStrings.perCent;
				}else if(currLine.contains("mean coverageData")){
					String[] splitted = currLine.split(" ");
					this.meanCoverage = splitted[splitted.length-1];
					this.meanCoverage = Main.toCorrectNumberFormat(this.meanCoverage);
//					this.meanCoverage = this.meanCoverage.replace(".", "");
//					this.meanCoverage = this.meanCoverage.replace(",", ".");
					this.meanCoverage = this.meanCoverage.replace("X", "");
				}else if(currLine.contains("std coverageData")){
					String[] splitted = currLine.split(" ");
					this.stdCoverage = splitted[splitted.length-1];
					this.stdCoverage = Main.toCorrectNumberFormat(this.stdCoverage);
//					this.stdCoverage = this.stdCoverage.replace(".", "");
//					this.stdCoverage = this.stdCoverage.replace(",", ".");
					this.stdCoverage = this.stdCoverage.replace("X", "");
				}else if(currLine.contains(">= 1X")){
					String[] splitted = currLine.trim().split(" ");
					if(splitted.length >= 4){
						this.coverage1x = splitted[3];
						this.coverage1x = this.coverage1x.replace(",", ".");
						this.coverage1x = this.coverage1x.replace("%", "");
						this.coverage1x += OutputStrings.perCent;
					}
				}else if(currLine.contains(">= 2X")){
					String[] splitted = currLine.trim().split(" ");
					if(splitted.length >= 4){
						this.coverage2x = splitted[3];
						this.coverage2x = this.coverage2x.replace(",", ".");
						this.coverage2x = this.coverage2x.replace("%", "");
						this.coverage2x += OutputStrings.perCent;
					}
				}else if(currLine.contains(">= 3X")){
					String[] splitted = currLine.trim().split(" ");
					if(splitted.length >= 4){
						this.coverage3x = splitted[3];
						this.coverage3x = this.coverage3x.replace(",", ".");
						this.coverage3x = this.coverage3x.replace("%", "");
						this.coverage3x += OutputStrings.perCent;
					}
				}else if(currLine.contains(">= 4X")){
					String[] splitted = currLine.trim().split(" ");
					if(splitted.length >= 4){
						this.coverage4x = splitted[3];
						this.coverage4x = this.coverage4x.replace(",", ".");
						this.coverage4x = this.coverage4x.replace("%", "");
						this.coverage4x += OutputStrings.perCent;
					}
				}else if(currLine.contains(">= 5X")){
					String[] splitted = currLine.trim().split(" ");
					if(splitted.length >= 4){
						this.coverage5x = splitted[3];
						this.coverage5x = this.coverage5x.replace(",", ".");
						this.coverage5x = this.coverage5x.replace("%", "");
						this.coverage5x += OutputStrings.perCent;
					}
				}
			}
		} catch (IOException e) {
		}
	}

	/**
	 * Getter method for the field containing the number of mapped reads
	 * @return the number of mapped reads
	 */
	public String getMappedReads() {
		return mappedReads;
	}

	/**
	 * Getter Method for the GC content
	 * @return the GC content
	 */
	public String getGc() {
		return gc;
	}

	/**
	 * @return the meanCoverage
	 */
	public String getMeanCoverage() {
		return meanCoverage;
	}

	/**
	 * @return the stdCoverage
	 */
	public String getStdCoverage() {
		return stdCoverage;
	}

}
